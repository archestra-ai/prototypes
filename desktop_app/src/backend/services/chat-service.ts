import { asc, desc, eq } from 'drizzle-orm';

import { chatsTable } from '@backend/database/schema/chat';
import { messagesTable } from '@backend/database/schema/messages';
import db from '@backend/database';

import { 
  type CreateChatRequest, 
  type UpdateChatRequest, 
  type ChatWithMessages as Chat,
  type InsertMessage,
  type Message
} from '@/types/db-schemas';

/**
 * Service layer for chat operations
 *
 * This service encapsulates all database operations for chats.
 * It's used by the Fastify routes to handle CRUD operations.
 *
 * Pattern: Repository/Service pattern to separate business logic from routes
 */
export class ChatService {
  async getAllChats(): Promise<Chat[]> {
    const chats = await db.select().from(chatsTable).orderBy(desc(chatsTable.createdAt)); // Most recent chats first

    return Promise.all(
      chats.map(async (chat) => ({
        id: chat.id,
        sessionId: chat.sessionId,
        title: chat.title,
        createdAt: chat.createdAt,
        updatedAt: chat.updatedAt,
        llm_provider: 'ollama', // Default provider for now
        messages: await this.getChatMessages(chat.id),
      }))
    );
  }

  async getChatById(id: number): Promise<Chat | null> {
    const results = await db.select().from(chatsTable).where(eq(chatsTable.id, id)).limit(1); // Ensure we only get one result

    const chat = results[0];
    if (!chat) return null;

    return {
      id: chat.id,
      sessionId: chat.sessionId,
      title: chat.title,
      createdAt: chat.createdAt,
      updatedAt: chat.updatedAt,
      llm_provider: 'ollama', // Default provider for now
      messages: await this.getChatMessages(chat.id),
    };
  }

  async createChat(request: CreateChatRequest): Promise<Chat> {
    // The sessionId is auto-generated by SQLite using the UUID expression
    // defined in the schema (see chat.ts schema file)
    const [chat] = await db
      .insert(chatsTable)
      .values({}) // No required fields, all handled by defaults
      .returning(); // SQLite returns the inserted row

    return {
      id: chat.id,
      sessionId: chat.sessionId,
      title: chat.title,
      createdAt: chat.createdAt,
      updatedAt: chat.updatedAt,
      llm_provider: request.llm_provider || 'ollama', // Use provided provider or default to ollama
      messages: [], // Empty messages array
    };
  }

  async updateChat(id: number, request: UpdateChatRequest): Promise<Chat | null> {
    // First check if the chat exists
    const chat = await this.getChatById(id);
    if (!chat) {
      return null; // Will trigger 404 in the route handler
    }

    const [updatedChat] = await db
      .update(chatsTable)
      .set({
        title: request.title,
        // Manually update the timestamp since SQLite doesn't have ON UPDATE
        updatedAt: new Date().toISOString(),
      })
      .where(eq(chatsTable.id, id))
      .returning();

    return {
      id: updatedChat.id,
      sessionId: updatedChat.sessionId,
      title: updatedChat.title,
      createdAt: updatedChat.createdAt,
      updatedAt: updatedChat.updatedAt,
      llm_provider: 'ollama', // Default provider for now
      messages: await this.getChatMessages(updatedChat.id),
    };
  }

  async deleteChat(id: number): Promise<void> {
    // Note: Related chat_interactions will be cascade deleted
    // when that table is added (foreign key constraint)
    await db.delete(chatsTable).where(eq(chatsTable.id, id));
  }

  async saveMessages(sessionId: string, messages: any[]): Promise<void> {
    // First, find the chat by session ID
    const [chat] = await db.select().from(chatsTable).where(eq(chatsTable.sessionId, sessionId)).limit(1);
    
    if (!chat) {
      console.error(`Chat not found for session ID: ${sessionId}`);
      return;
    }

    // Clear existing messages for this chat to avoid duplicates
    await db.delete(messagesTable).where(eq(messagesTable.chatId, chat.id));

    if (messages.length === 0) return;

    // Prepare all messages for batch insert
    const messagesToInsert = messages.map(message => ({
      chatId: chat.id,
      role: message.role,
      content: typeof message.content === 'string' ? message.content : JSON.stringify(message.content),
      metadata: message.images || message.thinking || message.toolCalls || message.tool_calls ? {
        images: message.images,
        thinking: message.thinking,
        toolCalls: message.toolCalls || message.tool_calls,
      } : undefined,
    }));

    // Batch insert all messages at once
    await db.insert(messagesTable).values(messagesToInsert);
  }

  async getChatMessages(chatId: number): Promise<Message[]> {
    const messages = await db
      .select()
      .from(messagesTable)
      .where(eq(messagesTable.chatId, chatId))
      .orderBy(asc(messagesTable.createdAt));
    
    return messages.map(msg => ({
      id: msg.id,
      chatId: msg.chatId,
      role: msg.role,
      content: msg.content,
      metadata: msg.metadata,
      createdAt: msg.createdAt,
    }));
  }
}

// Export a singleton instance for use in routes
export const chatService = new ChatService();
