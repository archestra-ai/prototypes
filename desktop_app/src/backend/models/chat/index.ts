import { type UIMessage } from 'ai';
import { asc, desc, eq } from 'drizzle-orm';
import { z } from 'zod';

import db from '@backend/database';
import { SelectChatSchema, chatsTable } from '@backend/database/schema/chat';
import {
  SelectMessagesSchema as DatabaseMessageRepresentationSchema,
  messagesTable,
} from '@backend/database/schema/messages';
import log from '@backend/utils/logger';

const TransformedMessageSchema = DatabaseMessageRepresentationSchema.extend({
  /**
   * NOTE: id is stored in the database as a number, but we will convert it to a string as such:
   * `${chat.sessionId}-${message.id}`
   */
  id: z.string(),
  /**
   * Content is a UIMessage from the 'ai' SDK
   */
  content: z.custom<UIMessage>(),
});

export const ChatWithMessagesSchema = SelectChatSchema.extend({
  messages: z.array(TransformedMessageSchema),
});

type DatabaseMessage = z.infer<typeof DatabaseMessageRepresentationSchema>;
type TransformedMessage = z.infer<typeof TransformedMessageSchema>;
type Chat = z.infer<typeof SelectChatSchema>;
type ChatWithMessages = z.infer<typeof ChatWithMessagesSchema>;

export default class ChatModel {
  static generateCompositeMessageId = (chat: Chat, message: DatabaseMessage): string =>
    `${chat.sessionId}-${message.id}`;

  static async getAllChats(): Promise<ChatWithMessages[]> {
    const rows = await db
      .select()
      .from(chatsTable)
      .leftJoin(messagesTable, eq(chatsTable.id, messagesTable.chatId))
      .orderBy(desc(chatsTable.createdAt), asc(messagesTable.createdAt)); // Most recent chats first, then messages in order

    // Use a Map for better performance and type safety
    const chatMap = new Map<number, ChatWithMessages>();

    for (const row of rows) {
      const chat = row.chats;
      const message = row.messages;

      if (!chatMap.has(chat.id)) {
        chatMap.set(chat.id, {
          ...chat,
          messages: [],
        });
      }

      if (message) {
        // Content is already a UIMessage, just need to update the id
        const parsedMessage = {
          ...message,
          id: `${chat.sessionId}-${message.id}`,
          content: message.content as UIMessage,
        };
        chatMap.get(chat.id)!.messages.push(parsedMessage);
      }
    }

    // Convert Map to array and sort by createdAt to maintain order
    return Array.from(chatMap.values()).sort(
      (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );
  }

  static async getChatById(id: number): Promise<ChatWithMessages | null> {
    const rows = await db
      .select()
      .from(chatsTable)
      .leftJoin(messagesTable, eq(chatsTable.id, messagesTable.chatId))
      .where(eq(chatsTable.id, id))
      .orderBy(asc(messagesTable.createdAt)); // Order messages by creation time

    if (rows.length === 0 || !rows[0].chats) {
      return null;
    }

    const chat = rows[0].chats;
    const messages: TransformedMessage[] = [];

    for (const row of rows) {
      if (row.messages) {
        messages.push({
          ...row.messages,
          id: this.generateCompositeMessageId(chat, row.messages),
          content: row.messages.content as UIMessage,
        });
      }
    }

    return {
      ...chat,
      messages,
    };
  }

  static async createChat(): Promise<ChatWithMessages> {
    // The sessionId is auto-generated by SQLite using the UUID expression
    // defined in the schema (see chat.ts schema file)
    const [chat] = await db
      .insert(chatsTable)
      .values({}) // No required fields, all handled by defaults
      .returning(); // SQLite returns the inserted row

    return {
      ...chat,
      messages: [],
    };
  }

  static async updateChat(id: number, data: { title?: string | null }): Promise<ChatWithMessages | null> {
    // First check if the chat exists
    const chat = await this.getChatById(id);
    if (!chat) {
      return null; // Will trigger 404 in the route handler
    }

    const [updatedChat] = await db
      .update(chatsTable)
      .set({
        title: data.title,
        // Manually update the timestamp since SQLite doesn't have ON UPDATE
        updatedAt: new Date().toISOString(),
      })
      .where(eq(chatsTable.id, id))
      .returning();

    return {
      ...updatedChat,
      messages: chat.messages, // Keep existing messages
    };
  }

  static async deleteChat(id: number): Promise<void> {
    // Note: Related chat_interactions will be cascade deleted
    // when that table is added (foreign key constraint)
    await db.delete(chatsTable).where(eq(chatsTable.id, id));
  }

  static async saveMessages(sessionId: string, messages: UIMessage[]): Promise<void> {
    // First, find the chat by session ID
    const [chat] = await db.select().from(chatsTable).where(eq(chatsTable.sessionId, sessionId)).limit(1);

    if (!chat) {
      log.error(`Chat not found for session ID: ${sessionId}`);
      return;
    }

    // Clear existing messages for this chat to avoid duplicates
    await db.delete(messagesTable).where(eq(messagesTable.chatId, chat.id));

    // Save each message with an explicit timestamp to preserve order
    const now = Date.now();
    for (let i = 0; i < messages.length; i++) {
      const message = messages[i];
      // Add a small offset to each message timestamp to preserve order
      const timestamp = new Date(now + i).toISOString();

      await db.insert(messagesTable).values({
        chatId: chat.id,
        role: message.role,
        content: message, // Store the entire UIMessage
        createdAt: timestamp, // Explicit timestamp with order preservation
      });
    }
  }
}
