import { desc, eq } from 'drizzle-orm';

import { chatsTable } from '@backend/database/schema/chat';
// IMPORTANT: Import from server/database, not the main database module
// The main database module uses Electron APIs which aren't available in the server process
import db from '@backend/server/database';

/**
 * Request/Response types for the chat API
 */
export interface CreateChatRequest {
  // Currently no required fields for creating a chat
}

export interface UpdateChatRequest {
  title?: string | null;
}

export interface Chat {
  id: number;
  sessionId: string;
  title: string | null;
  createdAt: string;
  updatedAt: string;
}

/**
 * Service layer for chat operations
 *
 * This service encapsulates all database operations for chats.
 * It's used by the Fastify routes to handle CRUD operations.
 *
 * Pattern: Repository/Service pattern to separate business logic from routes
 */
export class ChatService {
  async getAllChats(): Promise<Chat[]> {
    const chats = await db.select().from(chatsTable).orderBy(desc(chatsTable.createdAt)); // Most recent chats first

    return chats;
  }

  async getChatById(id: number): Promise<Chat | null> {
    const results = await db.select().from(chatsTable).where(eq(chatsTable.id, id)).limit(1); // Ensure we only get one result

    return results[0] || null;
  }

  async createChat(request: CreateChatRequest): Promise<Chat> {
    // The sessionId is auto-generated by SQLite using the UUID expression
    // defined in the schema (see chat.ts schema file)
    const [chat] = await db
      .insert(chatsTable)
      .values({}) // No required fields, all handled by defaults
      .returning(); // SQLite returns the inserted row

    return chat;
  }

  async updateChat(id: number, request: UpdateChatRequest): Promise<Chat | null> {
    // First check if the chat exists
    const chat = await this.getChatById(id);
    if (!chat) {
      return null; // Will trigger 404 in the route handler
    }

    const [updatedChat] = await db
      .update(chatsTable)
      .set({
        title: request.title,
        // Manually update the timestamp since SQLite doesn't have ON UPDATE
        updatedAt: new Date().toISOString(),
      })
      .where(eq(chatsTable.id, id))
      .returning();

    return updatedChat;
  }

  async deleteChat(id: number): Promise<void> {
    // Note: Related chat_interactions will be cascade deleted
    // when that table is added (foreign key constraint)
    await db.delete(chatsTable).where(eq(chatsTable.id, id));
  }
}

// Export a singleton instance for use in routes
export const chatService = new ChatService();
